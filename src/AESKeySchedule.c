#include "../include/AESKeySchedule.h"
#include "../include/AESConstants.h"
#include "../include/AESGlobals.h"
#include <stdio.h>
#include <stdlib.h>

// All 11/13/15 rounds keys from the cipher key are generated by this function
void keySchedule(uint8_t roundKeys[15][4][4], uint8_t cipherKey[4][8])
{
    if (keySizeInBits != 128 && keySizeInBits != 192 && keySizeInBits != 256)
    {
        printf("  Error! Invalid key size!");
        exit(EXIT_FAILURE);
    }
    int keySizeInBytes = keySizeInBits / 8;
    int Nk = keySizeInBytes / 4;            // Number of words in the cipher key
    int totalRounds = Nk + 6;               // AES standard: Rounds = Nk + 6
    int totalWords = (totalRounds + 1) * 4; // Total words for all round keys

    uint32_t words[totalWords]; // Each word = 4 bytes [0th - 1st - 2nd - 3rd]

    // Generating i'th word
    for (int i = 0; i < totalWords; i++)
    {
        if (i < Nk) // Step 1: Directly from cipher key
            words[i] = setByte(cipherKey[0][i], cipherKey[1][i], cipherKey[2][i], cipherKey[3][i]);
        else if (i % Nk == 0) // Step 2a: RotWord + SubWord + Rcon
            words[i] = words[i - Nk] ^ rCon(subWord(rotWord(words[i - 1])), i / Nk);
        else if (Nk == 8 && (i % Nk == 4)) // Step 2b: Special case for AES-256
            words[i] = words[i - Nk] ^ subWord(words[i - 1]);
        else // Step 2c: Default case
            words[i] = words[i - Nk] ^ words[i - 1];
    }

    // Load words into round keys
    for (int round = 0; round <= totalRounds; round++)
    {
        for (int col = 0; col < 4; col++)
        {
            uint32_t word = words[round * 4 + col];
            roundKeys[round][0][col] = (word >> 24) & 0xFF;
            roundKeys[round][1][col] = (word >> 16) & 0xFF;
            roundKeys[round][2][col] = (word >> 8) & 0xFF;
            roundKeys[round][3][col] = word & 0xFF;
        }
    }
}

// For KeySchedule: Circularly rotates the bytes of the Word to upwards once.
uint32_t rotWord(uint32_t word)
{
    // word = [0th byte - 1st byte - 2nd byte - 3rd byte]
    uint8_t byte0 = (word >> 24) & 0xFF;
    word = word << 8;
    word = word | byte0;
    return word;
}

// For KeySchedule: Substitutes bytes of the word with sbox
uint32_t subWord(uint32_t word)
{
    // word = [0th byte - 1st byte - 2nd byte - 3rd byte]
    uint32_t result = 0;
    for (int i = 0; i < 4; i++)
    {
        // Extract one byte (from most significant byte to least)
        uint8_t currByte = (word >> (24 - 8 * i)) & 0xFF;

        // Hexadecimal digit of the form 0x(XY)
        uint8_t X = currByte >> 4;
        uint8_t Y = currByte & 0x0F;

        uint8_t substitutedByte = sbox[X][Y];

        // Place the substituted byte back into the result
        result |= (substitutedByte << (24 - 8 * i));
    }
    return result;
}

// For KeySchedule: XORing of the received word with the round constants
uint32_t rCon(uint32_t word, int round)
{
    // word = [0th byte - 1st byte - 2nd byte - 3rd byte]
    word = word ^ (roundConstants[round] << 24);
    return word;
}

// For KeySchedule: Sets the bytes to correct location for each word
uint32_t setByte(int byte0, int byte1, int byte2, int byte3)
{
    // val= [byte0 : byte1 : byte2 : byte3]
    uint32_t val = 0;
    val = val | (byte0 << 24);
    val = val | (byte1 << 16);
    val = val | (byte2 << 8);
    val = val | (byte3 << 0);

    return val;
}